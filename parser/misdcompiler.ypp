%code requires {
    
 struct YYLTYPE {
    int         first_line;
    int         first_column;
    int         last_line;
    int         last_column;
    const char* comment;
  };

  #define YYLTYPE_IS_DECLARED 1
  #define YYLTYPE_IS_TRIVIAL  1
}

%{
 #define YYPARSE_PARAM scanner
 #define YYLEX_PARAM   scanner
%}	

%code requires {
 #include <stdio.h>
 #include <string.h>
 #include <vector>
 #include <iostream>
 
 #include "../include/Algorithm.h"
 
 #ifndef BUILD_H_
 #include "../include/build.h"
 #endif
 
 #ifndef IRGRAPH_H_
 #include "../include/IRGraph.h"
 #endif
 extern int yylineno; 
 
 static
 void yyerror(YYLTYPE* yyloc, IR_Graph& gr, char *s)
 {
        std::cerr << s << " at line " << yylineno << '\n';
 }
 
}

%code {
 std::vector< std::string > idents; 
 std::vector< std::string > exp_vars_list;
 std::vector< std::string > exp_bool_vars_list;
 std::vector< std::string > exp_nums_list;
 
 unsigned int scope_id = 0;//Identifier of a current scope
 
 extern int yylex( YYSTYPE* yylval_param, YYLTYPE* yylloc_param);
 int last_node = num_of_structures_for_usage;
}

// The names for the output files
%defines "../include/bison-misdcompiler.h"
%output  "bison-misdcompiler.cpp"

%parse-param { IR_Graph& gr }

%locations
%pure-parser

%union {	
 const char* pch;
 
 IR_Graph* graph;
 proc_type ptype;
 int type_int;
 std::string* str;
}

%start program

//Identifiers and literals
%token <pch> TIDENT
%token <pch> NUMLITERAL
%token <pch> TSTRUCTIDENT
%token <pch> STRINGLITERAL

//Keywords
%token TINT TDOUBLE TLONG TFLOAT TIF TTHEN TELSE TWHILE TDO TFOR 
//Keywords MISD-specific
//Type of memory used
%token TMEMTYPESPU TMEMTYPECPU
//Search and operations on individual element of structure
%token TMISDOPSEARCHSTR TMISDOPSEARCHSMLSTR TMISDOPSEARCHGRTSTR TMISDOPINSERTSTR TMISDOPDELETEFROMSTR TMISDOPNEXTSTR
//Operations on the whole structure
%token TMISDOPDELETESTR TMISDOPMAXSTR TMISDOPMINSTR TMISDOPPOWERSTR
//Operations on several operands
%token TMISDOPUNIONSTR TMISDOPINTERSECTSTR TMISDOPNOTSTR TMISDOPGTSTR TMISDOPLTSTR TMISDOPLTESTR TMISDOPGTESTR   
//Communication between SPU and CPU
%token TMISDOPSENDTOSPU TMISDOPSENDTOCPU TMISDOPRECEIVEFROMSPU TMISDOPRECEIVEFROMCPU

//Operators and punctuation
%token TPLUS TMINUS TDIV TMUL TMOD TAND TOR TNOT TLT TGT TLTE TGTE TEQ TCOMMA TSEMI TASSIGN

//Braces
%token TLCBR TRCBR TLP TRP

// keywords, operators, and punctuation that requires precedence
%left TNOELSE
%left TELSE
%left TCOMMA
%left TFOR TWHILE TIF
%left TOR
%left TAND
%left TEQ
%left TLTE TGTE TLT TGT
%left TPLUS TMINUS
%left TMUL TDIV TMOD
%right TNOT
%left TLP TLCBR

%type <graph> program stmts_ls stmt stmts_block assign_stmt loop_stmt count_loop while_loop if_stmt expr_stmt str_delete str_bin_expr str_compare_expr str_insert_to_str str_delete_from_str def_expr id_ls str_search_in_str
%type <str> struct ident num
%type <type_int> id_type

%%
program:
   stmts_ls															{
																		$$ = new IR_Graph();
																		last_node++;
																		IR_OperationNode * terminalNode = buildTerminalNode( );
																		terminalNode->setID(last_node);
																		$$->addOperationNode( terminalNode );
																		$$->appendGraph($1);
																		last_node++;
																		IR_OperationNode * terminalNode_end = buildTerminalNode( );
																		terminalNode_end->setID(last_node);
																		IR_Graph* last_gr = new IR_Graph();
																		last_gr->addOperationNode( terminalNode_end );
																		$$->appendGraph(last_gr);
																		
																		/* Printing section */
																		$$->printNodes();
																		$$->printConnections();
																		IR_Graph* sp_graph = Graph_StructureProcessing($$);
																		sp_graph->printNodes();
																		sp_graph->printConnections();
																		gr = *$$;
																	}
;

stmts_ls:
   stmt																{
																		$$ = new IR_Graph();
																		$$->appendGraph($1);
																	}
|  stmts_ls stmt													{
																		$$ = $1;
																		$$->appendGraph($2);
																	}
;

stmt:
   stmts_block														{ scope_id++; std::cout << "Scope ID: " << scope_id << std::endl; }
|  expr_stmt TSEMI													{ $$ = $1; }
|  assign_stmt TSEMI												{ $$ = $1; }
|  if_stmt				
|  loop_stmt			
;

stmts_block:
   TLCBR stmts_ls TRCBR												{ $$ = $2; }
|  TLCBR          TRCBR												{ $$ = new IR_Graph(); }
;

expr_stmt:
   																	{ $$ = new IR_Graph(); }
|  def_expr															{ $$ = $1; }
|  str_delete														{ $$ = $1; }
|  str_bin_expr														{ $$ = $1; }
|  str_compare_expr													{ $$ = $1; }
|  str_insert_to_str												{ $$ = $1; }
|  str_delete_from_str												{ $$ = $1; }
|  str_search_in_str												{ $$ = $1; }
;

def_expr:
   id_type id_ls													{
																		$$ = $2;
																		last_node++;
																		std::vector< std::string > * idents_ptr = &idents;
																		IR_OperationNode* op_node = buildDefineNode(idents_ptr);
																		op_node->setInstructionType(I_DEFINE);
																		op_node->setID(last_node);
																		$$->addOperationNode(op_node);
																		
																		std::vector< std::string >::size_type sz = idents.size();
																		
																		for(unsigned i = 0; i < sz; i++) {
																			std::string elem = idents[i];
																			updateDataNode_SimpleDataType(elem,$1);
																		}
																		
																		idents.clear();
																	}
;

id_type:
   TINT 			
|  TLONG			
|  TFLOAT			
|  TDOUBLE
;

id_ls:
   TIDENT															{
																		std::string ident_name(yylval.pch, 0, 1024);
																		last_node++;
																		buildDataNode(ident_name,IR_DATA_SIMPLE,last_node);
																		idents.reserve(1024);
																		idents.push_back(ident_name);
																		$$ = new IR_Graph();
																	}
|  id_ls TCOMMA TIDENT 												{
																		std::string ident_name(yylval.pch, 0, 1024);
																		last_node++;
																		buildDataNode(ident_name,IR_DATA_SIMPLE,last_node);
																		idents.push_back(ident_name);
																		$$ = $1;
																	}
;

str_delete:
   TMISDOPDELETESTR struct 											{
																		$$ = new IR_Graph();
																		addStructDataNodeToGraph(* $2);
																		last_node++;
																		IR_OperationNode* op_node = buildAssignNode(IR_DATA_STRUCTURE);
																		op_node->setInstructionType(I_STRUCTURE);
																		op_node->setID(last_node);
																		$$->addOperationNode(op_node);
																		IR_DataNode* data_node = getStructureNodeByName(* $2);
																		$$->addDataNode(data_node);
																		int op_node_id = $$->getLastOperationID();
																		int data_node_id = $$->getLastDataID();
																		if((data_node_id > 0) && (op_node_id > 0)) {
																			$$->addConnection(op_node_id,data_node_id);
																		}
																	}
;

str_bin_expr:
   str_bin_op struct TCOMMA struct TCOMMA struct					{
																		addStructDataNodeToGraph(* $2);
																		addStructDataNodeToGraph(* $4);
																		addStructDataNodeToGraph(* $6);
																		last_node++;
																		IR_OperationNode* op_node = buildAssignNode(IR_DATA_STRUCTURE);
																		op_node->setInstructionType(I_STRUCTURE);
																		op_node->setID(last_node);
																		$$ = new IR_Graph();
																		$$->addOperationNode(op_node);
																		IR_DataNode* data_node_result = getStructureNodeByName(* $2);
																		IR_DataNode* data_node_1 = getStructureNodeByName(* $4);
																		IR_DataNode* data_node_2 = getStructureNodeByName(* $6);
																		$$->addDataNode(data_node_result);
																		int data_node_result_id = $$->getLastDataID();
																		$$->addDataNode(data_node_1);
																		int data_node_1_id = $$->getLastDataID();
																		$$->addDataNode(data_node_2);
																		int data_node_2_id = $$->getLastDataID();
																		int op_node_id = $$->getLastOperationID();
																		
																		if((data_node_result_id > 0) && (op_node_id > 0) && (data_node_1_id > 0) && (data_node_2_id > 0)) {
																			$$->addConnection(op_node_id,data_node_result_id);
																			$$->addConnection(data_node_1_id,op_node_id);
																			$$->addConnection(data_node_2_id,op_node_id);
																		}
																	}
;

str_bin_op:
   TMISDOPUNIONSTR
|  TMISDOPINTERSECTSTR
|  TMISDOPNOTSTR
;

str_compare_expr:
   str_comp_op struct TCOMMA struct TCOMMA ident					{
																		addStructDataNodeToGraph(* $2);
																		addStructDataNodeToGraph(* $4);
																		last_node++;
																		IR_OperationNode* op_node = buildAssignNode(IR_DATA_STRUCTURE);
																		op_node->setInstructionType(I_STRUCTURE);
																		op_node->setID(last_node);
																		$$ = new IR_Graph();
																		$$->addOperationNode(op_node);
																		IR_DataNode* data_node_result = getStructureNodeByName(* $2);
																		IR_DataNode* data_node_1 = getStructureNodeByName(* $4);
																		IR_DataNode* data_node_2 = getVariableNodeByName(* $6);
																		$$->addDataNode(data_node_result);
																		int data_node_result_id = $$->getLastDataID();
																		$$->addDataNode(data_node_1);
																		int data_node_1_id = $$->getLastDataID();
																		bool * check_existence = new bool();
																		bool isAdded;
																		isAdded = isAddedToGraph(* $6, check_existence);
																		if( (* check_existence) == false ) {
																			char err[256];
																			const char *err_desc = "No such variable was declared: ";
																			const char * name_ident = $6->c_str();
																			strcpy(err,err_desc);
																			strcat(err,name_ident);
																			yyerror(0, *$$, err);
																		} else {
																			if( !isAdded ) {
																				$$->addDataNode(data_node_2);
																				int data_node_2_id = $$->getLastDataID();
																				addVariableDataNodeToGraph(* $6,data_node_2_id);
																			}
																		}
																		
																		int node_2_id = identNameToGID(* $6);
																		int op_node_id = $$->getLastOperationID();
																		if((data_node_result_id > 0) && (op_node_id > 0) && (data_node_1_id > 0) && (node_2_id > 0)) {
																			$$->addConnection(op_node_id,data_node_result_id);
																			$$->addConnection(data_node_1_id,op_node_id);
																			$$->addConnection(node_2_id,op_node_id);
																		}
																	}
;

str_comp_op:
   TMISDOPGTSTR
|  TMISDOPLTSTR
|  TMISDOPLTESTR
|  TMISDOPGTESTR
;

str_insert_to_str:
   TMISDOPINSERTSTR struct TCOMMA ident TCOMMA ident				{
																		addStructDataNodeToGraph(* $2);
																		last_node++;
																		IR_OperationNode* op_node = buildAssignNode(IR_DATA_STRUCTURE);
																		op_node->setInstructionType(I_STRUCTURE);
																		op_node->setID(last_node);
																		$$ = new IR_Graph();
																		$$->addOperationNode(op_node);
																		IR_DataNode* data_node_result = getStructureNodeByName(* $2);
																		IR_DataNode* data_node_1 = getVariableNodeByName(* $4);
																		IR_DataNode* data_node_2 = getVariableNodeByName(* $6);
																		$$->addDataNode(data_node_result);
																		int data_node_result_id = $$->getLastDataID();
																		bool * check_existence = new bool();
																		bool isAdded;
																		isAdded = isAddedToGraph(* $4, check_existence);
																		if( (* check_existence) == false ) {
																			char err[256];
																			const char *err_desc = "No such variable was declared: ";
																			const char * name_ident = $4->c_str();
																			strcpy(err,err_desc);
																			strcat(err,name_ident);
																			yyerror(0, *$$, err);
																		} else {
																			if( !isAdded ) {
																				$$->addDataNode(data_node_1);
																				int data_node_1_id = $$->getLastDataID();
																				addVariableDataNodeToGraph(* $4,data_node_1_id);
																			}
																		}
																		
																		int node_1_id = identNameToGID(* $4);
																		isAdded = isAddedToGraph(* $6, check_existence);
																		
																		if( (* check_existence) == false ) {
																			char err[256];
																			const char *err_desc = "No such variable was declared: ";
																			const char * name_ident = $6->c_str();
																			strcpy(err,err_desc);
																			strcat(err,name_ident);
																			yyerror(0, *$$, err);
																		} else {
																			if( !isAdded ) {
																				$$->addDataNode(data_node_2);
																				int data_node_2_id = $$->getLastDataID();
																				addVariableDataNodeToGraph(* $6,data_node_2_id);
																			}
																		}
																		
																		int node_2_id = identNameToGID(* $6);
																		int op_node_id = $$->getLastOperationID();
																		if((data_node_result_id > 0) && (op_node_id > 0) && (node_1_id > 0) && (node_2_id > 0)) {
																			$$->addConnection(op_node_id,data_node_result_id);
																			$$->addConnection(node_1_id,op_node_id);
																			$$->addConnection(node_2_id,op_node_id);
																		}
																	}
;

str_delete_from_str:
   TMISDOPDELETEFROMSTR struct TCOMMA ident							{
																		addStructDataNodeToGraph(* $2);
																		last_node++;
																		IR_OperationNode* op_node = buildAssignNode(IR_DATA_STRUCTURE);
																		op_node->setInstructionType(I_STRUCTURE);
																		op_node->setID(last_node);
																		$$ = new IR_Graph();
																		$$->addOperationNode(op_node);
																		IR_DataNode* data_node_result = getStructureNodeByName(* $2);
																		IR_DataNode* data_node_1 = getVariableNodeByName(* $4);
																		$$->addDataNode(data_node_result);
																		int data_node_result_id = $$->getLastDataID();
																		bool * check_existence = new bool();
																		bool isAdded;
																		isAdded = isAddedToGraph(* $4, check_existence);
																		
																		if( (* check_existence) == false ) {
																			char err[256];
																			const char *err_desc = "No such variable was declared: ";
																			const char * name_ident = $4->c_str();
																			strcpy(err,err_desc);
																			strcat(err,name_ident);
																			yyerror(0, *$$, err);
																		} else {
																			if( !isAdded ) {
																				$$->addDataNode(data_node_1);
																				int data_node_1_id = $$->getLastDataID();
																				addVariableDataNodeToGraph(* $4,data_node_1_id);
																			}
																		}
																		
																		int node_1_id = identNameToGID(* $4);
																		int op_node_id = $$->getLastOperationID();
																		if((data_node_result_id > 0) && (op_node_id > 0) && (node_1_id > 0)) {
																			$$->addConnection(op_node_id,data_node_result_id);
																			$$->addConnection(node_1_id,op_node_id);
																		}
																	}
;

str_search_in_str:
   struct_op_acq_elem ident TCOMMA struct TCOMMA ident				{
																		addStructDataNodeToGraph(* $4);
																		last_node++;
																		IR_OperationNode* op_node = buildAssignNode(IR_DATA_STRUCTURE);
																		op_node->setInstructionType(I_STRUCTURE);
																		op_node->setID(last_node);
																		$$ = new IR_Graph();
																		$$->addOperationNode(op_node);
																		int op_node_id = $$->getLastOperationID();
																		IR_DataNode* data_node_result = getVariableNodeByName(* $2);
																		bool * check_existence = new bool();
																		bool isAdded;
																		isAdded = isAddedToGraph(* $2, check_existence);
																		
																		if( (* check_existence) == false ) {
																			char err[256];
																			const char *err_desc = "No such variable was declared: ";
																			const char * name_ident = $2->c_str();
																			strcpy(err,err_desc);
																			strcat(err,name_ident);
																			yyerror(0, *$$, err);
																		} else {
																			if( !isAdded ) {
																				$$->addDataNode(data_node_result);
																				int data_node_result_id = $$->getLastDataID();
																				addVariableDataNodeToGraph(* $2,data_node_result_id);
																			}
																		}
																		
																		int res_id = identNameToGID(* $2);
																		IR_DataNode* data_node_1 = getStructureNodeByName(* $4);
																		$$->addDataNode(data_node_1);
																		int data_node_1_id = $$->getLastDataID();
																		IR_DataNode* data_node_2 = getVariableNodeByName(* $6);
																		isAdded = isAddedToGraph(* $6, check_existence);
																		if( (* check_existence) == false ) {
																			char err[256];
																			const char *err_desc = "No such variable was declared: ";
																			const char * name_ident = $6->c_str();
																			strcpy(err,err_desc);
																			strcat(err,name_ident);
																			yyerror(0, *$$, err);
																		} else {
																			if( !isAdded ) {
																				$$->addDataNode(data_node_2);
																				int data_node_2_id = $$->getLastDataID();
																				addVariableDataNodeToGraph(* $6,data_node_2_id);
																			}
																		}
																		
																		int node_2_id = identNameToGID(* $6);
																		
																		if((res_id > 0) && (op_node_id > 0) && (data_node_1_id > 0) && (node_2_id > 0)) {
																			$$->addConnection(op_node_id,res_id);
																			$$->addConnection(data_node_1_id,op_node_id);
																			$$->addConnection(node_2_id,op_node_id);
																		}
																	}
;	

struct_op_acq_elem:
   TMISDOPSEARCHSTR
|  TMISDOPSEARCHSMLSTR
|  TMISDOPSEARCHGRTSTR
|  TMISDOPNEXTSTR
;

assign_stmt:
   ident TASSIGN expr												{
																		data_type ident_type = getIdentType(* $1);
																		last_node++;
																		IR_OperationNode* op_node = buildAssignNode(ident_type);
																		op_node->setInstructionType(I_ASSIGN);
																		op_node->setID(last_node);
																		$$ = new IR_Graph();
																		$$->addOperationNode(op_node);
																		int op_node_id = $$->getLastOperationID();
																		IR_DataNode* data_node_result = getVariableNodeByName(* $1);
																		bool * check_existence = new bool();
																		bool isAdded;
																		isAdded = isAddedToGraph(* $1, check_existence);
																		
																		if( (* check_existence) == false ) {
																			char err[256];
																			const char *err_desc = "No such variable was declared: ";
																			const char * name_ident = $1->c_str();
																			strcpy(err,err_desc);
																			strcat(err,name_ident);
																			yyerror(0, *$$, err);
																		} else {
																			if( !isAdded ) {
																				$$->addDataNode(data_node_result);
																				int data_node_result_id = $$->getLastDataID();
																				addVariableDataNodeToGraph(* $1,data_node_result_id);
																			}
																		}
																		
																		int res_id = identNameToGID(* $1);
																		if((res_id > 0) && (op_node_id > 0)) {
																			$$->addConnection(op_node_id,res_id);
																		}
																		
																		int num_of_vars = exp_vars_list.size();
																		for(int i = 0; i < num_of_vars; i++ ) {
																			std::string variable_name = exp_vars_list[i];
																			IR_DataNode* data_node_i = getVariableNodeByName(variable_name);
																			isAdded = isAddedToGraph(variable_name, check_existence);
																			
																			if( (* check_existence) == false ) {
																				char err[256];
																				const char *err_desc = "No such variable was declared: ";
																				const char * name_ident = variable_name.c_str();
																				strcpy(err,err_desc);
																				strcat(err,name_ident);
																				yyerror(0, *$$, err);
																			} else {
																				if( !isAdded ) {
																					$$->addDataNode(data_node_i);
																					int data_node_i_id = $$->getLastDataID();
																					addVariableDataNodeToGraph(variable_name,data_node_i_id);
																				}
																			}
																			
																			int i_id = identNameToGID(variable_name);
																			if((i_id > 0) && (op_node_id > 0)) {
																				$$->addConnection(i_id,op_node_id);
																			}
																		}
																		
																		exp_vars_list.clear();
																	}
;

struct:
   TSTRUCTIDENT														{
																		std::string* ident_name = new std::string(yylval.pch, 0, 1024);
																		$$ = ident_name;
																	}
;

ident:
   TIDENT															{
																		std::string* ident_name = new std::string(yylval.pch, 0, 1024);
																		$$ = ident_name;
																	}
;

num:
   NUMLITERAL														{
																		std::string* num_str = new std::string(yylval.pch, 0, 1024);
																		double num = std::stod(*num_str);
																		std::cout << "Num: " << num << std::endl;
																	}
;

expr:
   TLP expr TRP														{ /* Only AST */ }
|  expr TPLUS expr													{ /* Only AST */ }
|  expr TMINUS expr													{ /* Only AST */ }
|  expr TMUL expr													{ /* Only AST */ }
|  expr TDIV expr													{ /* Only AST */ }
|  expr TMOD expr													{ /* Only AST */ }
|  expr TAND expr													{ /* Only AST */ }
|  expr TOR expr													{ /* Only AST */ }
|  TNOT expr														{ /* Only AST */ }
|  ident															{ exp_vars_list.push_back(* $1); }
|  num																{}
;

if_stmt:
   TIF TLP bool_expr TRP TTHEN stmt %prec TNOELSE					{
																		$$ = new IR_Graph();
																		last_node++;
																		IR_OperationNode * cond_node = buildConditionalBeginBranchNode( );
																		cond_node->setInstructionType(I_IF);
																		cond_node->setID(last_node);
																		$$->addOperationNode( cond_node );
																		int op_node_id = $$->getLastOperationID();
																		$$->appendGraph($6);
																		int op_last_appended = $$->getLastOperationID();
																		last_node++;
																		IR_OperationNode * end_node = buildEndBranchNode( );
																		end_node->setInstructionType(I_IF);
																		end_node->setID(last_node);
																		$$->addOperationNode( end_node );
																		int op_end_node_id = $$->getLastOperationID();
																		cond_node->setConnectedNodeID(op_end_node_id);
																		end_node->setConnectedNodeID(op_node_id);
																		$$->addConnection(op_node_id,op_end_node_id);
																		$$->addConnection(op_last_appended,op_end_node_id);
																		int num_of_vars = exp_bool_vars_list.size();
																		bool * check_existence = new bool();
																		bool isAdded;
																		
																		for(int i = 0; i < num_of_vars; i++ ) {
																			std::string variable_name = exp_bool_vars_list[i];
																			IR_DataNode* data_node_i = getVariableNodeByName(variable_name);
																			isAdded = isAddedToGraph(variable_name, check_existence);
																			if( (* check_existence) == false ) {
																				char err[256]; const char *err_desc = "No such variable was declared: ";
																				const char * name_ident = variable_name.c_str();
																				strcpy(err,err_desc);
																				strcat(err,name_ident);
																				yyerror(0, *$$, err);
																			} else {
																				if( !isAdded ) {
																					$$->addDataNode(data_node_i);
																					int data_node_i_id = $$->getLastDataID();
																					addVariableDataNodeToGraph(variable_name,data_node_i_id);
																				}
																			}
																			
																			int i_id = identNameToGID(variable_name);
																			if((i_id > 0) && (op_node_id > 0)) {
																				$$->addConnection(i_id,op_node_id);
																			}
																		}
																		
																		exp_bool_vars_list.clear();
																	}
|  TIF TLP bool_expr TRP TTHEN stmt TELSE stmt						{
																		$$ = new IR_Graph();
																		last_node++;
																		IR_OperationNode * cond_node = buildConditionalBeginBranchNode( );
																		cond_node->setInstructionType(I_IF_ELSE);
																		cond_node->setID(last_node);
																		$$->addOperationNode( cond_node );
																		int op_node_id = $$->getLastOperationID();
																		$$->appendGraph($6);
																		int op_last_appended_1 = $$->getLastOperationID();
																		$$->appendGraph($8,op_node_id);
																		int op_last_appended_2 = $$->getLastOperationID();
																		last_node++;
																		IR_OperationNode * end_node = buildEndBranchNode( );
																		end_node->setInstructionType(I_IF_ELSE);
																		end_node->setID(last_node);
																		$$->addOperationNode( end_node );
																		int op_end_node_id = $$->getLastOperationID();
																		cond_node->setConnectedNodeID(op_end_node_id);
																		end_node->setConnectedNodeID(op_node_id);
																		$$->addConnection(op_last_appended_1,op_end_node_id);
																		$$->addConnection(op_last_appended_2,op_end_node_id);
																		int num_of_vars = exp_bool_vars_list.size();
																		bool * check_existence = new bool();
																		bool isAdded;
																		
																		for(int i = 0; i < num_of_vars; i++ ) {
																			std::string variable_name = exp_bool_vars_list[i];
																			IR_DataNode* data_node_i = getVariableNodeByName(variable_name);
																			isAdded = isAddedToGraph(variable_name, check_existence);
																			if( (* check_existence) == false ) {
																				char err[256];
																				const char *err_desc = "No such variable was declared: ";
																				const char * name_ident = variable_name.c_str();
																				strcpy(err,err_desc);
																				strcat(err,name_ident);
																				yyerror(0, *$$, err);
																			} else {
																				if( !isAdded ) {
																					$$->addDataNode(data_node_i);
																					int data_node_i_id = $$->getLastDataID();
																					addVariableDataNodeToGraph(variable_name,data_node_i_id);
																				}
																			}
																			
																			int i_id = identNameToGID(variable_name);
																			if((i_id > 0) && (op_node_id > 0)) {
																				$$->addConnection(i_id,op_node_id);
																			}
																		}
																		
																		exp_bool_vars_list.clear();
																	}
;

bool_expr:
   expr log_op expr													{
																		int num_of_vars = exp_vars_list.size();
																		
																		for(int i = 0; i < num_of_vars; i++ ) {
																			exp_bool_vars_list.push_back(exp_vars_list[i]);
																		}
																		
																		exp_vars_list.clear(); /* Only AST */
																	}
;

log_op:
   TLT				
|  TGT				
|  TLTE				
|  TGTE				
|  TEQ				
;

loop_stmt:
   count_loop			
|  while_loop			
;

count_loop:
   TFOR TLP assign_stmt TSEMI bool_expr TSEMI assign_stmt TRP stmt	{
																		$$ = new IR_Graph();
																		$$->appendGraph($3);
																		last_node++;
																		IR_OperationNode * cond_node = buildConditionalBeginBranchNode( );
																		cond_node->setInstructionType(I_FOR_LOOP);
																		cond_node->setID(last_node);
																		$$->addOperationNode( cond_node );
																		int op_node_id = $$->getLastOperationID();
																		int num_of_vars = exp_bool_vars_list.size();
																		
																		for(int i = 0; i < num_of_vars; i++ ) {
																			std::string variable_name = exp_bool_vars_list[i];
																			IR_DataNode* data_node_i = getVariableNodeByName(variable_name);
																			$$->addDataNode(data_node_i);
																			int data_node_i_id = $$->getLastDataID();
																			if((data_node_i_id > 0) && (op_node_id > 0)) {
																				$$->addConnection(data_node_i_id,op_node_id);
																			}
																		}
																		
																		exp_bool_vars_list.clear();
																		int op_cnt_assign_id = $3->getLastOperationID();
																		$$->addConnection(op_cnt_assign_id,op_node_id);
																		$$->appendGraph($7);
																		$$->appendGraph($9);
																		int op_last_appended = $$->getLastOperationID();
																		last_node++;
																		IR_OperationNode * end_node = buildEndBranchNode( );
																		end_node->setInstructionType(I_FOR_LOOP);
																		end_node->setID(last_node);
																		$$->addOperationNode( end_node );
																		int op_end_node_id = $$->getLastOperationID();
																		cond_node->setConnectedNodeID(op_node_id);
																		cond_node->setLastNodeID_forLoops(op_last_appended);
																		end_node->setConnectedNodeID(op_node_id);
																		$$->addConnection(op_last_appended,op_node_id);
																		$$->addConnection(op_node_id,op_end_node_id);
																	}
;

while_loop:
   TWHILE TLP bool_expr TRP TDO stmt								{ 
																	   $$ = new IR_Graph(); 
																	   last_node++; 
																	   IR_OperationNode * cond_node = buildConditionalBeginBranchNode( );
																	   cond_node->setInstructionType(I_WHILE_LOOP);
																	   cond_node->setID(last_node);
																	   $$->addOperationNode( cond_node );
																	   int op_node_id = $$->getLastOperationID();
																	   int num_of_vars = exp_bool_vars_list.size();
																	   
																	   for(int i = 0; i < num_of_vars; i++ ) {
																		   std::string variable_name = exp_bool_vars_list[i];
																		   IR_DataNode* data_node_i = getVariableNodeByName(variable_name);
																		   $$->addDataNode(data_node_i);
																		   int data_node_i_id = $$->getLastDataID();
																		   
																		   if((data_node_i_id > 0) && (op_node_id > 0)) { 
																			   $$->addConnection(data_node_i_id,op_node_id);
																			}
																			
																		}
																		
																		exp_bool_vars_list.clear();
																		$$->appendGraph($6);
																		int op_last_appended = $$->getLastOperationID();
																		last_node++;
																		IR_OperationNode * end_node = buildEndBranchNode( );
																		end_node->setInstructionType(I_WHILE_LOOP);
																		end_node->setID(last_node);
																		$$->addOperationNode( end_node );
																		int op_end_node_id = $$->getLastOperationID();
																		cond_node->setConnectedNodeID(op_node_id);
																		cond_node->setLastNodeID_forLoops(op_last_appended);
																		end_node->setConnectedNodeID(op_node_id);
																		$$->addConnection(op_last_appended,op_node_id);
																		$$->addConnection(op_node_id,op_end_node_id);
																	}
;

%%
