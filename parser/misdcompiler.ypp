%code requires {
    
 struct YYLTYPE {
    int         first_line;
    int         first_column;
    int         last_line;
    int         last_column;
    const char* comment;
  };

  #define YYLTYPE_IS_DECLARED 1
  #define YYLTYPE_IS_TRIVIAL  1
}

%{
 #define YYPARSE_PARAM scanner
 #define YYLEX_PARAM   scanner
%}	

%code requires {
 #include <stdio.h>
 #include <string.h>
 #include <vector>
 #include <iostream>
 
 #include "../include/Algorithm.h"
 
 #ifndef BUILD_H_
 #include "../include/build.h"
 #endif
 
 #ifndef IRGRAPH_H_
 #include "../include/IRGraph.h"
 #endif
 
 #ifndef BASEAST_H_
 #include "../include/BaseAST.h"
 #endif
 
 extern int yylineno; 
 
 static
 void yyerror(YYLTYPE* yyloc, IR_Graph& gr, char *s)
 {
        std::cerr << s << " at line " << yylineno << '\n';
 }
 
}

%code {
 std::vector< std::string > idents; 
 std::vector< std::string > scopes_ids_list {"0"};
 std::vector< std::string > exp_vars_list;
 std::vector< std::string > exp_bool_vars_list;
 std::vector< std::string > exp_nums_list;
 
 unsigned int scope_id = 0;//Identifier of a current scope
 
 extern int yylex( YYSTYPE* yylval_param, YYLTYPE* yylloc_param);
 int last_node = num_of_structures_for_usage;
}

// The names for the output files
%defines "../include/bison-misdcompiler.h"
%output  "bison-misdcompiler.cpp"

%parse-param { IR_Graph& gr }

%locations
%pure-parser

%union {	
 const char* pch;
 
 IR_Graph* graph;
 proc_type ptype;
 int type_int;
 double numerical;
 std::string* str;
 variable_type tov;
 Base_AST * ast;
 LogicalExpression * logic;
 cond_op_types cond;
}

%start program

//Identifiers and literals
%token <pch> TIDENT
%token <pch> NUMLITERAL
%token <pch> TSTRUCTIDENT
%token <pch> STRINGLITERAL

//Keywords
%token TINT TDOUBLE TLONG TFLOAT TIF TTHEN TELSE TWHILE TDO TFOR 
//Keywords MISD-specific
//Type of memory used
%token TMEMTYPESPU TMEMTYPECPU
//Search and operations on individual element of structure
%token TMISDOPSEARCHSTR TMISDOPSEARCHSMLSTR TMISDOPSEARCHGRTSTR TMISDOPINSERTSTR TMISDOPDELETEFROMSTR TMISDOPNEXTSTR
//Operations on the whole structure
%token TMISDOPDELETESTR TMISDOPMAXSTR TMISDOPMINSTR TMISDOPPOWERSTR
//Operations on several operands
%token TMISDOPUNIONSTR TMISDOPINTERSECTSTR TMISDOPNOTSTR TMISDOPGTSTR TMISDOPLTSTR TMISDOPLTESTR TMISDOPGTESTR   
//Communication between SPU and CPU
%token TMISDOPSENDTOSPU TMISDOPSENDTOCPU TMISDOPRECEIVEFROMSPU TMISDOPRECEIVEFROMCPU

//Operators and punctuation
%token TPLUS TMINUS TDIV TMUL TMOD TAND TOR TNOT TLT TGT TLTE TGTE TEQ TCOMMA TSEMI TASSIGN

//Braces
%token TLCBR TRCBR TLP TRP

// keywords, operators, and punctuation that requires precedence
%left TNOELSE
%left TELSE
%left TCOMMA
%left TFOR TWHILE TIF
%left TOR
%left TAND
%left TEQ
%left TLTE TGTE TLT TGT
%left TPLUS TMINUS
%left TMUL TDIV TMOD
%right TNOT
%left TLP TLCBR

%type <graph> program stmts_ls stmt stmts_block assign_stmt loop_stmt count_loop while_loop if_stmt expr_stmt str_delete str_bin_expr str_compare_expr str_insert_to_str str_delete_from_str def_expr id_ls str_search_in_str
%type <str> struct ident
%type <type_int> tlc trc
%type <tov> id_type
%type <ast> expr
%type <numerical> num
%type <logic> bool_expr
%type <cond> log_op

%%
program:
   stmts_ls															{
																		$$ = new IR_Graph();
																		last_node++;
																		IR_OperationNode * terminalNode = buildTerminalNode( );
																		terminalNode->setID(last_node);
																		terminalNode->setScopesIDs(scopes_ids_list);
																		$$->addOperationNode( terminalNode );
																		$$->appendGraph($1);
																		last_node++;
																		IR_OperationNode * terminalNode_end = buildTerminalNode( );
																		terminalNode_end->setID(last_node);
																		terminalNode_end->setScopesIDs(scopes_ids_list);
																		IR_Graph* last_gr = new IR_Graph();
																		last_gr->addOperationNode( terminalNode_end );
																		$$->appendGraph(last_gr);
																		$$->printNodes();
																		gr = *$$;
																	}
;

stmts_ls:
   stmt																{
																		$$ = new IR_Graph();
																		$$->appendGraph($1);
																	}
|  stmts_ls stmt													{
																		$$ = $1;
																		$$->appendGraph($2);
																	}
;

stmt:
   stmts_block														
|  expr_stmt TSEMI													{ $$ = $1; }
|  assign_stmt TSEMI												{ $$ = $1; }
|  if_stmt				
|  loop_stmt			
;

stmts_block:
   tlc stmts_ls trc													{ $$ = $2; }
|  tlc          trc													{ $$ = new IR_Graph(); }
;

tlc:
   TLCBR															{
																		std::string scope_id_s = std::to_string(++scope_id);
																		scopes_ids_list.push_back(scope_id_s);
																	}
   
trc:
   TRCBR															{ 
																		scopes_ids_list.pop_back();
																	}

expr_stmt:
   																	{ $$ = new IR_Graph(); }
|  def_expr															{ $$ = $1; }
|  str_delete														{ $$ = $1; }
|  str_bin_expr														{ $$ = $1; }
|  str_compare_expr													{ $$ = $1; }
|  str_insert_to_str												{ $$ = $1; }
|  str_delete_from_str												{ $$ = $1; }
|  str_search_in_str												{ $$ = $1; }
;

def_expr:
   id_type id_ls													{
																		$$ = $2;
																		last_node++;
																		std::vector< std::string > * idents_ptr = &idents;
																		IR_OperationNode* op_node = buildDefineNode(idents_ptr, $1);
																		op_node->setInstructionType(I_DEFINE);
																		op_node->setID(last_node);
																		op_node->setScopesIDs(scopes_ids_list);
																		$$->addOperationNode(op_node);
																		
																		std::vector< std::string >::size_type sz = idents.size();
																		
																		for(unsigned i = 0; i < sz; i++) {
																			std::string elem = idents[i];
																			std::vector< std::string > scopes_ids_list_cp = scopes_ids_list;
																			std::vector< std::string > * scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																			updateDataNode_SimpleDataType(elem,$1,scopes_ids_list_cp_ptr);
																		}

																		idents.clear();
																	}
;

id_type:
   TINT 															{ $$ = VAR_INT; }
|  TLONG															{ $$ = VAR_LONG; }
|  TFLOAT															{ $$ = VAR_FLOAT; }
|  TDOUBLE															{ $$ = VAR_DOUBLE; }
;

id_ls:
   TIDENT															{
																		std::string ident_name(yylval.pch, 0, 1024);
																		last_node++;
																		int ercode = buildDataNode(ident_name,IR_DATA_SIMPLE,last_node,scopes_ids_list.back());
																		if(ercode == 1) {
																			char err[256];
																			const char *err_desc = "ERROR. Variable declared more than one time in the same scope: ";
																			const char * name_ident = ident_name.c_str();
																			strcpy(err,err_desc);
																			strcat(err,name_ident);
																			yyerror(0, *$$, err);
																		} else {
																			idents.reserve(1024);
																			idents.push_back(ident_name);
																			$$ = new IR_Graph();
																		}
																	}
|  id_ls TCOMMA TIDENT 												{
																		std::string ident_name(yylval.pch, 0, 1024);
																		last_node++;
																		int ercode = buildDataNode(ident_name,IR_DATA_SIMPLE,last_node,scopes_ids_list.back());
																		if(ercode == 1) {
																			char err[256];
																			const char *err_desc = "ERROR. Variable declared more than one time in the same scope: ";
																			const char * name_ident = ident_name.c_str();
																			strcpy(err,err_desc);
																			strcat(err,name_ident);
																			yyerror(0, *$$, err);
																		} else {
																			idents.push_back(ident_name);
																			$$ = $1;
																		}
																	}
;

str_delete:
   TMISDOPDELETESTR struct 											{
																		$$ = new IR_Graph();
																		addStructDataNodeToGraph(* $2);
																		last_node++;
																		std::vector< std::string > * idents_ptr = new std::vector< std::string >;
																		idents_ptr->push_back(* $2);
																		std::vector< std::string > scopes_ids_list_cp = scopes_ids_list;
																		std::vector< std::string > * scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																		IR_OperationNode* op_node = buildAssignNode(IR_DATA_STRUCTURE, idents_ptr, NULL, scopes_ids_list_cp_ptr);
																		op_node->setInstructionType(I_STRUCTURE);
																		op_node->setID(last_node);
																		op_node->setScopesIDs(scopes_ids_list);
																		$$->addOperationNode(op_node);
																		IR_DataNode* data_node = getStructureNodeByName(* $2);
																		$$->addDataNode(data_node);
																		int op_node_id = $$->getLastOperationID();
																		int data_node_id = $$->getLastDataID();
																		if((data_node_id > 0) && (op_node_id > 0)) {
																			$$->addConnection(op_node_id,data_node_id);
																		}
																	}
;

str_bin_expr:
   str_bin_op struct TCOMMA struct TCOMMA struct					{
																		addStructDataNodeToGraph(* $2);
																		addStructDataNodeToGraph(* $4);
																		addStructDataNodeToGraph(* $6);
																		last_node++;
																		std::vector< std::string > * idents_ptr = new std::vector< std::string >;
																		idents_ptr->push_back(* $2);
																		idents_ptr->push_back(* $4);
																		idents_ptr->push_back(* $6);
																		std::vector< std::string > scopes_ids_list_cp = scopes_ids_list;
																		std::vector< std::string > * scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																		IR_OperationNode* op_node = buildAssignNode(IR_DATA_STRUCTURE,idents_ptr, NULL, scopes_ids_list_cp_ptr);
																		op_node->setInstructionType(I_STRUCTURE);
																		op_node->setID(last_node);
																		op_node->setScopesIDs(scopes_ids_list);
																		$$ = new IR_Graph();
																		$$->addOperationNode(op_node);
																		IR_DataNode* data_node_result = getStructureNodeByName(* $2);
																		IR_DataNode* data_node_1 = getStructureNodeByName(* $4);
																		IR_DataNode* data_node_2 = getStructureNodeByName(* $6);
																		$$->addDataNode(data_node_result);
																		int data_node_result_id = $$->getLastDataID();
																		$$->addDataNode(data_node_1);
																		int data_node_1_id = $$->getLastDataID();
																		$$->addDataNode(data_node_2);
																		int data_node_2_id = $$->getLastDataID();
																		int op_node_id = $$->getLastOperationID();
																		
																		if((data_node_result_id > 0) && (op_node_id > 0) && (data_node_1_id > 0) && (data_node_2_id > 0)) {
																			$$->addConnection(op_node_id,data_node_result_id);
																			$$->addConnection(data_node_1_id,op_node_id);
																			$$->addConnection(data_node_2_id,op_node_id);
																		}
																	}
;

str_bin_op:
   TMISDOPUNIONSTR
|  TMISDOPINTERSECTSTR
|  TMISDOPNOTSTR
;

str_compare_expr:
   str_comp_op struct TCOMMA struct TCOMMA ident					{
																		addStructDataNodeToGraph(* $2);
																		addStructDataNodeToGraph(* $4);
																		last_node++;
																		std::vector< std::string > * idents_ptr = new std::vector< std::string >;
																		idents_ptr->push_back(* $2);
																		idents_ptr->push_back(* $4);
																		idents_ptr->push_back(* $6);
																		std::vector< std::string > scopes_ids_list_cp = scopes_ids_list;
																		std::vector< std::string > * scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																		IR_OperationNode* op_node = buildAssignNode(IR_DATA_STRUCTURE,idents_ptr, NULL, scopes_ids_list_cp_ptr);
																		op_node->setInstructionType(I_STRUCTURE);
																		op_node->setID(last_node);
																		op_node->setScopesIDs(scopes_ids_list);
																		$$ = new IR_Graph();
																		$$->addOperationNode(op_node);
																		IR_DataNode* data_node_result = getStructureNodeByName(* $2);
																		IR_DataNode* data_node_1 = getStructureNodeByName(* $4);
																		std::vector< std::string > scopes_ids_list_cp = scopes_ids_list;
																		std::vector< std::string > * scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																		IR_DataNode* data_node_2 = getVariableNodeByName(* $6, scopes_ids_list_cp_ptr);
																		$$->addDataNode(data_node_result);
																		int data_node_result_id = $$->getLastDataID();
																		$$->addDataNode(data_node_1);
																		int data_node_1_id = $$->getLastDataID();
																		
																		if(data_node_2 != NULL) {
																			std::string data_node_2_name = data_node_2->getDataName();
																			bool * check_existence = new bool();
																			bool isAdded;
																			scopes_ids_list_cp = scopes_ids_list;
																			scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																			isAdded = isAddedToGraph(data_node_2_name, check_existence, scopes_ids_list_cp_ptr);
																			if( (* check_existence) == true ) {
																				if( !isAdded ) {
																					$$->addDataNode(data_node_2);
																					int data_node_2_id = $$->getLastDataID();
																					scopes_ids_list_cp = scopes_ids_list;
																					scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																					addVariableDataNodeToGraph(data_node_2_name,data_node_2_id,scopes_ids_list_cp_ptr);
																				}
																			}
																		
																			scopes_ids_list_cp = scopes_ids_list;
																			scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																			int node_2_id = identNameToGID(data_node_2_name,scopes_ids_list_cp_ptr);
																			int op_node_id = $$->getLastOperationID();
																			if((data_node_result_id > 0) && (op_node_id > 0) && (data_node_1_id > 0) && (node_2_id > 0)) {
																				$$->addConnection(op_node_id,data_node_result_id);
																				$$->addConnection(data_node_1_id,op_node_id);
																				$$->addConnection(node_2_id,op_node_id);
																			}
																		} else {
																			char err[256];
																			const char *err_desc = "No such variable was declared: ";
																			const char * name_ident = $6->c_str();
																			strcpy(err,err_desc);
																			strcat(err,name_ident);
																			yyerror(0, *$$, err);
																		}
																	}
;

str_comp_op:
   TMISDOPGTSTR
|  TMISDOPLTSTR
|  TMISDOPLTESTR
|  TMISDOPGTESTR
;

str_insert_to_str:
   TMISDOPINSERTSTR struct TCOMMA ident TCOMMA ident				{
																		addStructDataNodeToGraph(* $2);
																		last_node++;
																		std::vector< std::string > * idents_ptr = new std::vector< std::string >;
																		idents_ptr->push_back(* $2);
																		idents_ptr->push_back(* $4);
																		idents_ptr->push_back(* $6);
																		std::vector< std::string > scopes_ids_list_cp = scopes_ids_list;
																		std::vector< std::string > * scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																		IR_OperationNode* op_node = buildAssignNode(IR_DATA_STRUCTURE,idents_ptr, NULL, scopes_ids_list_cp_ptr);
																		op_node->setInstructionType(I_STRUCTURE);
																		op_node->setID(last_node);
																		op_node->setScopesIDs(scopes_ids_list);
																		$$ = new IR_Graph();
																		$$->addOperationNode(op_node);
																		IR_DataNode* data_node_result = getStructureNodeByName(* $2);
																		scopes_ids_list_cp = scopes_ids_list;
																		scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																		IR_DataNode* data_node_1 = getVariableNodeByName(* $4, scopes_ids_list_cp_ptr);
																		scopes_ids_list_cp = scopes_ids_list;
																		scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																		IR_DataNode* data_node_2 = getVariableNodeByName(* $6, scopes_ids_list_cp_ptr);
																		$$->addDataNode(data_node_result);
																		int data_node_result_id = $$->getLastDataID();
																		
																		if(data_node_1 != NULL) {
																			std::string data_node_1_name = data_node_1->getDataName();
																			bool * check_existence = new bool();
																			bool isAdded;
																			scopes_ids_list_cp = scopes_ids_list;
																			scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																			isAdded = isAddedToGraph(data_node_1_name, check_existence,scopes_ids_list_cp_ptr);
																			if( (* check_existence) == true ) {
																				if( !isAdded ) {
																					$$->addDataNode(data_node_1);
																					int data_node_1_id = $$->getLastDataID();
																					scopes_ids_list_cp = scopes_ids_list;
																					scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																					addVariableDataNodeToGraph(data_node_1_name,data_node_1_id,scopes_ids_list_cp_ptr);
																				}
																			}
																			
																			scopes_ids_list_cp = scopes_ids_list;
																			scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																			int node_1_id = identNameToGID(data_node_1_name,scopes_ids_list_cp_ptr);
																			if(data_node_2 != NULL) {
																				std::string data_node_2_name = data_node_1->getDataName();
																				scopes_ids_list_cp = scopes_ids_list;
																				scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																				isAdded = isAddedToGraph(data_node_2_name, check_existence, scopes_ids_list_cp_ptr);
																			
																				if( (* check_existence) == true ) {
																					if( !isAdded ) {
																						$$->addDataNode(data_node_2);
																						int data_node_2_id = $$->getLastDataID();
																						scopes_ids_list_cp = scopes_ids_list;
																						scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																						addVariableDataNodeToGraph(data_node_2_name,data_node_2_id,scopes_ids_list_cp_ptr);
																					}
																				}
																			
																				scopes_ids_list_cp = scopes_ids_list;
																				scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																				int node_2_id = identNameToGID(data_node_2_name,scopes_ids_list_cp_ptr);
																				int op_node_id = $$->getLastOperationID();
																			
																				if((data_node_result_id > 0) && (op_node_id > 0) && (node_1_id > 0) && (node_2_id > 0)) {
																					$$->addConnection(op_node_id,data_node_result_id);
																					$$->addConnection(node_1_id,op_node_id);
																					$$->addConnection(node_2_id,op_node_id);
																				}
																			} else {
																				char err[256];
																				const char *err_desc = "No such variable was declared: ";
																				const char * name_ident = $6->c_str();
																				strcpy(err,err_desc);
																				strcat(err,name_ident);
																				yyerror(0, *$$, err);
																			}
																		} else {
																			char err[256];
																			const char *err_desc = "No such variable was declared: ";
																			const char * name_ident = $4->c_str();
																			strcpy(err,err_desc);
																			strcat(err,name_ident);
																			yyerror(0, *$$, err);
																		}
																	}
;

str_delete_from_str:
   TMISDOPDELETEFROMSTR struct TCOMMA ident							{
																		addStructDataNodeToGraph(* $2);
																		last_node++;
																		std::vector< std::string > * idents_ptr = new std::vector< std::string >;
																		idents_ptr->push_back(* $2);
																		idents_ptr->push_back(* $4);
																		std::vector< std::string > scopes_ids_list_cp = scopes_ids_list;
																		std::vector< std::string > * scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																		IR_OperationNode* op_node = buildAssignNode(IR_DATA_STRUCTURE,idents_ptr, NULL, scopes_ids_list_cp_ptr);
																		op_node->setInstructionType(I_STRUCTURE);
																		op_node->setID(last_node);
																		op_node->setScopesIDs(scopes_ids_list);
																		$$ = new IR_Graph();
																		$$->addOperationNode(op_node);
																		IR_DataNode* data_node_result = getStructureNodeByName(* $2);
																		scopes_ids_list_cp = scopes_ids_list;
																		scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																		IR_DataNode* data_node_1 = getVariableNodeByName(* $4, scopes_ids_list_cp_ptr);
																		$$->addDataNode(data_node_result);
																		int data_node_result_id = $$->getLastDataID();
																		
																		if(data_node_1 != NULL) {
																			std::string data_node_1_name = data_node_1->getDataName();
																			bool * check_existence = new bool();
																			bool isAdded;
																			scopes_ids_list_cp = scopes_ids_list;
																			scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																			isAdded = isAddedToGraph(data_node_1_name, check_existence,scopes_ids_list_cp_ptr);
																			if( (* check_existence) == true ) {
																				if( !isAdded ) {
																					$$->addDataNode(data_node_1);
																					int data_node_1_id = $$->getLastDataID();
																					scopes_ids_list_cp = scopes_ids_list;
																					scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																					addVariableDataNodeToGraph(data_node_1_name,data_node_1_id,scopes_ids_list_cp_ptr);
																				}
																			}
																		
																			scopes_ids_list_cp = scopes_ids_list;
																			scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																			int node_1_id = identNameToGID(data_node_1_name,scopes_ids_list_cp_ptr);
																			int op_node_id = $$->getLastOperationID();
																			if((data_node_result_id > 0) && (op_node_id > 0) && (node_1_id > 0)) {
																				$$->addConnection(op_node_id,data_node_result_id);
																				$$->addConnection(node_1_id,op_node_id);
																			}
																		} else {
																			char err[256];
																			const char *err_desc = "No such variable was declared: ";
																			const char * name_ident = $4->c_str();
																			strcpy(err,err_desc);
																			strcat(err,name_ident);
																			yyerror(0, *$$, err);
																		}
																	}
;

str_search_in_str:
   struct_op_acq_elem ident TCOMMA struct TCOMMA ident				{
																		addStructDataNodeToGraph(* $4);
																		last_node++;
																		std::vector< std::string > * idents_ptr = new std::vector< std::string >;
																		idents_ptr->push_back(* $2);
																		idents_ptr->push_back(* $4);
																		idents_ptr->push_back(* $6);
																		std::vector< std::string > scopes_ids_list_cp = scopes_ids_list;
																		std::vector< std::string > * scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																		IR_OperationNode* op_node = buildAssignNode(IR_DATA_STRUCTURE,idents_ptr, NULL, scopes_ids_list_cp_ptr);
																		op_node->setInstructionType(I_STRUCTURE);
																		op_node->setID(last_node);
																		op_node->setScopesIDs(scopes_ids_list);
																		$$ = new IR_Graph();
																		$$->addOperationNode(op_node);
																		int op_node_id = $$->getLastOperationID();
																		IR_DataNode* data_node_1 = getStructureNodeByName(* $4);
																		$$->addDataNode(data_node_1);
																		int data_node_1_id = $$->getLastDataID();
																		
																		scopes_ids_list_cp = scopes_ids_list;
																		scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																		IR_DataNode* data_node_result = getVariableNodeByName(* $2, scopes_ids_list_cp_ptr);
																		scopes_ids_list_cp = scopes_ids_list;
																		scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																		IR_DataNode* data_node_2 = getVariableNodeByName(* $6, scopes_ids_list_cp_ptr);
																		
																		if(data_node_result != NULL) {
																			std::string data_node_result_name = data_node_result->getDataName();
																			bool * check_existence = new bool();
																			bool isAdded;
																			scopes_ids_list_cp = scopes_ids_list;
																			scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																			isAdded = isAddedToGraph(data_node_result_name, check_existence,scopes_ids_list_cp_ptr);
																			if( (* check_existence) == true ) {
																				if( !isAdded ) {
																					$$->addDataNode(data_node_result);
																					int data_node_result_id = $$->getLastDataID();
																					scopes_ids_list_cp = scopes_ids_list;
																					scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																					addVariableDataNodeToGraph(data_node_result_name,data_node_result_id,scopes_ids_list_cp_ptr);
																				}
																			}
																			
																			scopes_ids_list_cp = scopes_ids_list;
																			scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																			int res_id = identNameToGID(data_node_result_name,scopes_ids_list_cp_ptr);
																			if(data_node_2 != NULL) {
																				std::string data_node_2_name = data_node_1->getDataName();
																				scopes_ids_list_cp = scopes_ids_list;
																				scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																				isAdded = isAddedToGraph(data_node_2_name, check_existence,  scopes_ids_list_cp_ptr);
																			
																				if( (* check_existence) == true ) {
																					if( !isAdded ) {
																						$$->addDataNode(data_node_2);
																						int data_node_2_id = $$->getLastDataID();
																						scopes_ids_list_cp = scopes_ids_list;
																						scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																						addVariableDataNodeToGraph(data_node_2_name,data_node_2_id,scopes_ids_list_cp_ptr);
																					}
																				}
																			
																				scopes_ids_list_cp = scopes_ids_list;
																				scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																				int node_2_id = identNameToGID(data_node_2_name,scopes_ids_list_cp_ptr);
																			
																				if((res_id > 0) && (op_node_id > 0) && (data_node_1_id > 0) && (node_2_id > 0)) {
																					$$->addConnection(op_node_id,res_id);
																					$$->addConnection(data_node_1_id,op_node_id);
																					$$->addConnection(node_2_id,op_node_id);
																				}
																			} else {
																				char err[256];
																				const char *err_desc = "No such variable was declared: ";
																				const char * name_ident = $6->c_str();
																				strcpy(err,err_desc);
																				strcat(err,name_ident);
																				yyerror(0, *$$, err);
																			}
																		} else {
																			char err[256];
																			const char *err_desc = "No such variable was declared: ";
																			const char * name_ident = $2->c_str();
																			strcpy(err,err_desc);
																			strcat(err,name_ident);
																			yyerror(0, *$$, err);
																		}
																	}
;	

struct_op_acq_elem:
   TMISDOPSEARCHSTR
|  TMISDOPSEARCHSMLSTR
|  TMISDOPSEARCHGRTSTR
|  TMISDOPNEXTSTR
;

assign_stmt:
   ident TASSIGN expr												{
   																		std::vector< std::string > scopes_ids_list_cp = scopes_ids_list;
																		std::vector< std::string > * scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																		data_type ident_type = getIdentType(* $1,scopes_ids_list_cp_ptr);
																		last_node++;
																		std::vector< std::string > * idents_ptr = new std::vector< std::string >;
																		idents_ptr->push_back(* $1);
																		scopes_ids_list_cp = scopes_ids_list;
																		scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																		IR_OperationNode* op_node = buildAssignNode(ident_type, idents_ptr, $3, scopes_ids_list_cp_ptr);
																		op_node->setInstructionType(I_ASSIGN);
																		op_node->setID(last_node);
																		op_node->setScopesIDs(scopes_ids_list);
																		$$ = new IR_Graph();
																		$$->addOperationNode(op_node);
																		int op_node_id = $$->getLastOperationID();
																		scopes_ids_list_cp = scopes_ids_list;
																		scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																		IR_DataNode* data_node_result = getVariableNodeByName(* $1, scopes_ids_list_cp_ptr);
																		
																		if(data_node_result != NULL) {
																			std::string data_node_result_name = data_node_result->getDataName();
																			bool * check_existence = new bool();
																			bool isAdded;
																			scopes_ids_list_cp = scopes_ids_list;
																			scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																			isAdded = isAddedToGraph(data_node_result_name, check_existence, scopes_ids_list_cp_ptr);
																			if( (* check_existence) == true ) {
																				if( !isAdded ) {
																					$$->addDataNode(data_node_result);
																					int data_node_result_id = $$->getLastDataID();
																					scopes_ids_list_cp = scopes_ids_list;
																					scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																					addVariableDataNodeToGraph(data_node_result_name,data_node_result_id,scopes_ids_list_cp_ptr);
																				}
																			}
																		
																			scopes_ids_list_cp = scopes_ids_list;
																			scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																			int res_id = identNameToGID(data_node_result_name,scopes_ids_list_cp_ptr);
																			if((res_id > 0) && (op_node_id > 0)) {
																				$$->addConnection(op_node_id,res_id);
																			}
																		} else {
																			char err[256];
																			const char *err_desc = "No such variable was declared: ";
																			const char * name_ident = $1->c_str();
																			strcpy(err,err_desc);
																			strcat(err,name_ident);
																			yyerror(0, *$$, err);
																		}
																		
																		int num_of_vars = exp_vars_list.size();
																		for(int i = 0; i < num_of_vars; i++ ) {
																			std::string variable_name = exp_vars_list[i];

																			scopes_ids_list_cp = scopes_ids_list;
																			scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																			IR_DataNode* data_node_i = getVariableNodeByName(variable_name, scopes_ids_list_cp_ptr);
																			
																			if(data_node_i != NULL) {
																				std::string data_node_i_name = data_node_i->getDataName();
																				bool * check_existence = new bool();
																				bool isAdded;
																				scopes_ids_list_cp = scopes_ids_list;
																				scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																				isAdded = isAddedToGraph(data_node_i_name, check_existence, scopes_ids_list_cp_ptr);
																				if( (* check_existence) == true ) {
																					if( !isAdded ) {
																						$$->addDataNode(data_node_i);
																						int data_node_i_id = $$->getLastDataID();
																						scopes_ids_list_cp = scopes_ids_list;
																						scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																						addVariableDataNodeToGraph(data_node_i_name,data_node_i_id,scopes_ids_list_cp_ptr);
																					}
																				}
																		
																				scopes_ids_list_cp = scopes_ids_list;
																				scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																				int i_id = identNameToGID(data_node_i_name,scopes_ids_list_cp_ptr);
																				if((i_id > 0) && (op_node_id > 0)) {
																					$$->addConnection(i_id,op_node_id);
																				}
																			} else {
																				char err[256];
																				const char *err_desc = "No such variable was declared: ";
																				const char * name_ident = variable_name.c_str();
																				strcpy(err,err_desc);
																				strcat(err,name_ident);
																				yyerror(0, *$$, err);
																			}
																		}
																		
																		exp_vars_list.clear();
																	}
;

struct:
   TSTRUCTIDENT														{
																		std::string* ident_name = new std::string(yylval.pch, 0, 1024);
																		$$ = ident_name;
																	}
;

ident:
   TIDENT															{
																		std::string* ident_name = new std::string(yylval.pch, 0, 1024);
																		$$ = ident_name;
																	}
;

num:
   NUMLITERAL														{
																		std::string* num_str = new std::string(yylval.pch, 0, 1024);
																		double num = std::stod(*num_str);
																	}
;

expr:
   TLP expr TRP														{	$$ = $2; }
|  expr TPLUS expr													{	$$ = buildBinaryExpression($1, $3, OP_PLUS); }
|  expr TMINUS expr													{	$$ = buildBinaryExpression($1, $3, OP_MINUS); }
|  expr TMUL expr													{	$$ = buildBinaryExpression($1, $3, OP_MUL); }
|  expr TDIV expr													{	$$ = buildBinaryExpression($1, $3, OP_DIV); }
|  expr TMOD expr													{	$$ = buildBinaryExpression($1, $3, OP_MOD); }
|  expr TAND expr													{	$$ = buildBinaryExpression($1, $3, OP_AND); }
|  expr TOR expr													{	$$ = buildBinaryExpression($1, $3, OP_OR); }
|  TNOT expr														{	$$ = buildUnaryExpression($2, OP_NOT); }
|  ident															{
																		exp_vars_list.push_back(* $1);
																		std::vector< std::string > scopes_ids_list_cp = scopes_ids_list;
																		std::vector< std::string > * scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																		$$ = buildVariableExpr(* $1, scopes_ids_list_cp_ptr);
																	}
|  num																{	$$ = buildNumberExpr( $1 ); }
;

if_stmt:
   TIF TLP bool_expr TRP TTHEN stmt %prec TNOELSE					{
																		$$ = new IR_Graph();
																		last_node++;
																		int first_then = $6->getFirstOperationID();
																		IR_OperationNode * cond_node = buildConditionalBeginBranchNode( $3, I_IF );
																		cond_node->setID(last_node);
																		cond_node->setScopesIDs(scopes_ids_list);
																		cond_node->setThenID(first_then);
																		$$->addOperationNode( cond_node );
																		int op_node_id = $$->getLastOperationID();
																		$$->appendGraph($6);
																		int op_last_appended = $$->getLastOperationID();
																		last_node++;
																		IR_OperationNode * end_node = buildEndBranchNode( I_IF );
																		end_node->setID(last_node);
																		end_node->setScopesIDs(scopes_ids_list);
																		$$->addOperationNode( end_node );
																		int op_end_node_id = $$->getLastOperationID();
																		cond_node->setConnectedNodeID(op_end_node_id);
																		end_node->setConnectedNodeID(op_node_id);
																		$$->addConnection(op_node_id,op_end_node_id);
																		$$->addConnection(op_last_appended,op_end_node_id);
																		int num_of_vars = exp_bool_vars_list.size();
																		bool * check_existence = new bool();
																		bool isAdded;
																		
																		for(int i = 0; i < num_of_vars; i++ ) {
																			std::string variable_name = exp_bool_vars_list[i];
																			std::vector< std::string > scopes_ids_list_cp = scopes_ids_list;
																			std::vector< std::string > * scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																			IR_DataNode* data_node_i = getVariableNodeByName(variable_name, scopes_ids_list_cp_ptr);
																			
																			if(data_node_i != NULL) {
																				std::string data_node_i_name = data_node_i->getDataName();
																				bool * check_existence = new bool();
																				bool isAdded;
																				scopes_ids_list_cp = scopes_ids_list;
																				scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																				isAdded = isAddedToGraph(data_node_i_name, check_existence,scopes_ids_list_cp_ptr);
																				if( (* check_existence) == true ) {
																					if( !isAdded ) {
																						$$->addDataNode(data_node_i);
																						int data_node_i_id = $$->getLastDataID();
																						scopes_ids_list_cp = scopes_ids_list;
																						scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																						addVariableDataNodeToGraph(data_node_i_name,data_node_i_id,scopes_ids_list_cp_ptr);
																					}
																				}
																		
																				scopes_ids_list_cp = scopes_ids_list;
																				scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																				int i_id = identNameToGID(data_node_i_name,scopes_ids_list_cp_ptr);
																				if((i_id > 0) && (op_node_id > 0)) {
																					$$->addConnection(i_id,op_node_id);
																				}
																			} else {
																				char err[256];
																				const char *err_desc = "No such variable was declared: ";
																				const char * name_ident = variable_name.c_str();
																				strcpy(err,err_desc);
																				strcat(err,name_ident);
																				yyerror(0, *$$, err);
																			}
																		}
																		
																		exp_bool_vars_list.clear();
																	}
|  TIF TLP bool_expr TRP TTHEN stmt TELSE stmt						{
																		$$ = new IR_Graph();
																		last_node++;
																		int first_then = $6->getFirstOperationID();
																		int first_else = $8->getFirstOperationID();
																		IR_OperationNode * cond_node = buildConditionalBeginBranchNode( $3, I_IF_ELSE );
																		cond_node->setID(last_node);
																		cond_node->setScopesIDs(scopes_ids_list);
																		cond_node->setThenID(first_then);
																		cond_node->setElseID(first_else);
																		$$->addOperationNode( cond_node );
																		int op_node_id = $$->getLastOperationID();
																		$$->appendGraph($6);
																		int op_last_appended_1 = $$->getLastOperationID();
																		$$->appendGraph($8,op_node_id);
																		int op_last_appended_2 = $$->getLastOperationID();
																		last_node++;
																		IR_OperationNode * end_node = buildEndBranchNode( I_IF_ELSE );
																		end_node->setID(last_node);
																		end_node->setScopesIDs(scopes_ids_list);
																		$$->addOperationNode( end_node );
																		int op_end_node_id = $$->getLastOperationID();
																		cond_node->setConnectedNodeID(op_end_node_id);
																		end_node->setConnectedNodeID(op_node_id);
																		$$->addConnection(op_last_appended_1,op_end_node_id);
																		$$->addConnection(op_last_appended_2,op_end_node_id);
																		int num_of_vars = exp_bool_vars_list.size();
																		bool * check_existence = new bool();
																		bool isAdded;
																		
																		for(int i = 0; i < num_of_vars; i++ ) {
																			std::string variable_name = exp_bool_vars_list[i];
																			std::vector< std::string > scopes_ids_list_cp = scopes_ids_list;
																			std::vector< std::string > * scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																			IR_DataNode* data_node_i = getVariableNodeByName(variable_name, scopes_ids_list_cp_ptr);
																			
																			if(data_node_i != NULL) {
																				std::string data_node_i_name = data_node_i->getDataName();
																				bool * check_existence = new bool();
																				bool isAdded;
																				scopes_ids_list_cp = scopes_ids_list;
																				scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																				isAdded = isAddedToGraph(data_node_i_name, check_existence,scopes_ids_list_cp_ptr);
																				if( (* check_existence) == true ) {
																					if( !isAdded ) {
																						$$->addDataNode(data_node_i);
																						int data_node_i_id = $$->getLastDataID();
																						scopes_ids_list_cp = scopes_ids_list;
																						scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																						addVariableDataNodeToGraph(data_node_i_name,data_node_i_id,scopes_ids_list_cp_ptr);
																					}
																				}
																		
																				scopes_ids_list_cp = scopes_ids_list;
																				scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																				int i_id = identNameToGID(data_node_i_name,scopes_ids_list_cp_ptr);
																				if((i_id > 0) && (op_node_id > 0)) {
																					$$->addConnection(i_id,op_node_id);
																				}
																			} else {
																				char err[256];
																				const char *err_desc = "No such variable was declared: ";
																				const char * name_ident = variable_name.c_str();
																				strcpy(err,err_desc);
																				strcat(err,name_ident);
																				yyerror(0, *$$, err);
																			}
																		}
																		
																		exp_bool_vars_list.clear();
																	}
;

bool_expr:
   expr log_op expr													{
																		int num_of_vars = exp_vars_list.size();
																		
																		for(int i = 0; i < num_of_vars; i++ ) {
																			exp_bool_vars_list.push_back(exp_vars_list[i]);
																		}
																		
																		exp_vars_list.clear();
																		$$ = buildLogicalExpr($1,$3,$2);
																	}
;

log_op:
   TLT																{ $$ = OP_LT; }
|  TGT																{ $$ = OP_GT; }
|  TLTE																{ $$ = OP_LTE; }
|  TGTE																{ $$ = OP_GTE; }
|  TEQ																{ $$ = OP_EQ; }
;

loop_stmt:
   count_loop			
|  while_loop			
;

count_loop:
   TFOR TLP assign_stmt TSEMI bool_expr TSEMI assign_stmt TRP stmt	{
																		$$ = new IR_Graph();
																		$$->appendGraph($3);
																		last_node++;
																		int first_then = $9->getFirstOperationID();
																		IR_OperationNode * cond_node = buildConditionalBeginBranchNode( $5, I_FOR_LOOP );
																		cond_node->setID(last_node);
																		cond_node->setScopesIDs(scopes_ids_list);
																		cond_node->setThenID(first_then);
																		$$->addOperationNode( cond_node );
																		int op_node_id = $$->getLastOperationID();
																		int num_of_vars = exp_bool_vars_list.size();
																		
																		for(int i = 0; i < num_of_vars; i++ ) {
																			std::string variable_name = exp_bool_vars_list[i];
																			std::vector< std::string > scopes_ids_list_cp = scopes_ids_list;
																			std::vector< std::string > * scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																			IR_DataNode* data_node_i = getVariableNodeByName(variable_name, scopes_ids_list_cp_ptr);
																			
																			if(data_node_i != NULL) {
																				std::string data_node_i_name = data_node_i->getDataName();
																				bool * check_existence = new bool();
																				bool isAdded;
																				scopes_ids_list_cp = scopes_ids_list;
																				scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																				isAdded = isAddedToGraph(data_node_i_name, check_existence,scopes_ids_list_cp_ptr);
																				if( (* check_existence) == true ) {
																					if( !isAdded ) {
																						$$->addDataNode(data_node_i);
																						int data_node_i_id = $$->getLastDataID();
																						scopes_ids_list_cp = scopes_ids_list;
																						scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																						addVariableDataNodeToGraph(data_node_i_name,data_node_i_id,scopes_ids_list_cp_ptr);
																					}
																				}
																				
																				scopes_ids_list_cp = scopes_ids_list;
																				scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																				int i_id = identNameToGID(data_node_i_name, scopes_ids_list_cp_ptr);
																				if((i_id > 0) && (op_node_id > 0)) {
																					$$->addConnection(i_id,op_node_id);
																				}
																			} else {
																				char err[256];
																				const char *err_desc = "No such variable was declared: ";
																				const char * name_ident = variable_name.c_str();
																				strcpy(err,err_desc);
																				strcat(err,name_ident);
																				yyerror(0, *$$, err);
																			}
																		}
																		
																		exp_bool_vars_list.clear();
																		int op_cnt_assign_id = $3->getLastOperationID();
																		$$->addConnection(op_cnt_assign_id,op_node_id);
																		$$->appendGraph($9);
																		$$->appendGraph($7);//Placing assignment of a new iteration index value at the end of current iteration
																		int op_last_appended = $$->getLastOperationID();
																		last_node++;
																		IR_OperationNode * end_node = buildEndBranchNode( I_FOR_LOOP );
																		end_node->setID(last_node);
																		end_node->setScopesIDs(scopes_ids_list);
																		$$->addOperationNode( end_node );
																		int op_end_node_id = $$->getLastOperationID();
																		cond_node->setElseID(op_end_node_id);
																		cond_node->setConnectedNodeID(op_node_id);
																		cond_node->setLastNodeID_forLoops(op_last_appended);
																		end_node->setConnectedNodeID(op_node_id);
																		$$->addConnection(op_last_appended,op_node_id);
																		$$->addConnection(op_node_id,op_end_node_id);
																	}
;

while_loop:
   TWHILE TLP bool_expr TRP TDO stmt								{ 
																	   $$ = new IR_Graph(); 
																	   last_node++;
																	   int first_then = $6->getFirstOperationID();
																	   IR_OperationNode * cond_node = buildConditionalBeginBranchNode( $3, I_WHILE_LOOP );
																	   cond_node->setID(last_node);
																	   cond_node->setScopesIDs(scopes_ids_list);
																	   cond_node->setThenID(first_then);
																	   $$->addOperationNode( cond_node );
																	   int op_node_id = $$->getLastOperationID();
																	   int num_of_vars = exp_bool_vars_list.size();
																	   
																	   for(int i = 0; i < num_of_vars; i++ ) {
																		   std::string variable_name = exp_bool_vars_list[i];
																		   std::vector< std::string > scopes_ids_list_cp = scopes_ids_list;
																			std::vector< std::string > * scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																			IR_DataNode* data_node_i = getVariableNodeByName(variable_name, scopes_ids_list_cp_ptr);
																			
																			if(data_node_i != NULL) {
																				std::string data_node_i_name = data_node_i->getDataName();
																				bool * check_existence = new bool();
																				bool isAdded;
																				scopes_ids_list_cp = scopes_ids_list;
																				scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																				isAdded = isAddedToGraph(data_node_i_name, check_existence,scopes_ids_list_cp_ptr);
																				if( (* check_existence) == true ) {
																					if( !isAdded ) {
																						$$->addDataNode(data_node_i);
																						int data_node_i_id = $$->getLastDataID();
																						scopes_ids_list_cp = scopes_ids_list;
																						scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																						addVariableDataNodeToGraph(data_node_i_name,data_node_i_id,scopes_ids_list_cp_ptr);
																					}
																				}
																				
																				scopes_ids_list_cp = scopes_ids_list;
																				scopes_ids_list_cp_ptr = &scopes_ids_list_cp;
																				int i_id = identNameToGID(data_node_i_name, scopes_ids_list_cp_ptr);
																				if((i_id > 0) && (op_node_id > 0)) {
																					$$->addConnection(i_id,op_node_id);
																				}
																			} else {
																				char err[256];
																				const char *err_desc = "No such variable was declared: ";
																				const char * name_ident = variable_name.c_str();
																				strcpy(err,err_desc);
																				strcat(err,name_ident);
																				yyerror(0, *$$, err);
																			}
																		}
																		
																		exp_bool_vars_list.clear();
																		$$->appendGraph($6);
																		int op_last_appended = $$->getLastOperationID();
																		last_node++;
																		IR_OperationNode * end_node = buildEndBranchNode( I_WHILE_LOOP );
																		end_node->setID(last_node);
																		end_node->setScopesIDs(scopes_ids_list);
																		$$->addOperationNode( end_node );
																		int op_end_node_id = $$->getLastOperationID();
																		cond_node->setElseID(op_end_node_id);
																		cond_node->setConnectedNodeID(op_node_id);
																		cond_node->setLastNodeID_forLoops(op_last_appended);
																		end_node->setConnectedNodeID(op_node_id);
																		$$->addConnection(op_last_appended,op_node_id);
																		$$->addConnection(op_node_id,op_end_node_id);
																	}
;

%%
