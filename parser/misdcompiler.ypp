%code requires {
    
 struct YYLTYPE {
    int         first_line;
    int         first_column;
    int         last_line;
    int         last_column;
    const char* comment;
  };

  #define YYLTYPE_IS_DECLARED 1
  #define YYLTYPE_IS_TRIVIAL  1
}

%{
 #define YYPARSE_PARAM scanner
 #define YYLEX_PARAM   scanner
%}	

%code {
 #include <stdio.h>
 #include "build.h"
 extern int yylex( YYSTYPE* yylval_param, YYLTYPE* yylloc_param);
 
 static
 void yyerror(char *s)
 {
        printf("yyerror: %s\n", s);
 }
}

// The names for the output files
%defines "../include/bison-misdcompiler.h"
%output  "bison-misdcompiler.cpp"

%locations
%pure-parser

%union {	
 const char* pch;
}

%start program

//Identifiers and literals
%token <pch> TIDENT
%token <pch> NUMLITERAL
%token <pch> TSTRUCTIDENT
%token <pch> STRINGLITERAL

//Keywords
%token TINT TCHAR TLONG TFLOAT TIF TTHEN TELSE TWHILE TDO TFOR 
//Keywords MISD-specific
//Type of memory used
%token TMEMTYPESPU TMEMTYPECPU
//Search and operations on individual element of structure
%token TMISDOPSEARCHSTR TMISDOPSEARCHSMLSTR TMISDOPSEARCHGRTSTR TMISDOPINSERTSTR TMISDOPDELETEFROMSTR TMISDOPNEXTSTR
//Operations on the whole structure
%token TMISDOPDELETESTR TMISDOPMAXSTR TMISDOPMINSTR TMISDOPPOWERSTR
//Operations on several operands
%token TMISDOPUNIONSTR TMISDOPINTERSECTSTR TMISDOPNOTSTR TMISDOPGTSTR TMISDOPLTSTR TMISDOPLTESTR TMISDOPGTESTR   
//Communication between SPU and CPU
%token TMISDOPSENDTOSPU TMISDOPSENDTOCPU TMISDOPRECEIVEFROMSPU TMISDOPRECEIVEFROMCPU

//Operators and punctuation
%token TPLUS TMINUS TDIV TMUL TMOD TAND TOR TNOT TLT TGT TLTE TGTE TEQ TCOMMA TSEMI TASSIGN

//Braces
%token TLCBR TRCBR TLP TRP

// keywords, operators, and punctuation that requires precedence
%left TNOELSE
%left TELSE
%left TCOMMA
%left TFOR TWHILE TIF
%left TOR
%left TAND
%left TEQ
%left TLTE TGTE TLT TGT
%left TPLUS TMINUS
%left TMUL TDIV TMOD
%right TNOT
%left TLP TLCBR

%%
program:
   stmts_ls			{ printf("Syntactical analysis completed successfully\n"); }
;

stmts_ls:
						{ $$ = new IR_Graph(); $$->addOperationNode( buildTerminalNode( ) ); }
|  stmts_ls stmt		{ $$ = $1->appendGraph($2); }
;

stmt:
   stmts_block			
|  expr_stmt TSEMI		{ printf("Expression statement\n"); }
|  assign_stmt TSEMI	
|  if_stmt				
|  loop_stmt			
;

stmts_block:
   TLCBR stmts_ls TRCBR		{ printf("Non-empty statements block\n"); }
|  TLCBR          TRCBR		{ printf("Empty statements block\n"); }
;

expr_stmt:
   				{ printf("NOP\n"); }
|  def_expr TSEMI		{ printf("Definition expression\n"); }
|  str_delete TSEMI		{ printf("Delete structure\n"); }
|  str_bin_expr TSEMI		{ printf("Binary expression\n"); }
|  str_compare_expr TSEMI	{ printf("Compare expression\n"); }
|  str_transmission_expr TSEMI	{ printf("Transmission expression\n"); }
;

def_expr:
   id_type id_ls		{ std::vector<int>::size_type sz = $2.size(); for(unsigned i = 0; i < sz; i++) { updateDataNode_DataType($2[i],$1); } //$$= ???  }
;

id_type:
   TINT 			
|  TCHAR 			
|  TLONG			
|  TFLOAT			
;

id_ls:
   mem_type TIDENT		{ std::vector< std::string > idents; idents.reserve(1024); std::string ident_name(llval, 0, 1024); buildDataNode(ident_name,$1); idents.push_back(ident_name); $$ = idents; }
|  id_ls TCOMMA mem_type TIDENT { std::string ident_name(llval, 0, 1024); buildDataNode(ident_name,$3); $1.push_back(ident_name); $$ = $1; }
;

mem_type:
   TMEMTYPESPU			{ $$ = IR_SPU; }
|  TMEMTYPECPU			{ $$ = IR_CPU; }
;

str_delete:
   TMISDOPDELETESTR TSTRUCTIDENT { printf("Deletion of structure\n"); }
;

str_bin_expr:
   TMISDOPUNIONSTR TSTRUCTIDENT TCOMMA TSTRUCTIDENT TCOMMA TSTRUCTIDENT		{ printf("Structure union\n"); }
|  TMISDOPINTERSECTSTR TSTRUCTIDENT TCOMMA TSTRUCTIDENT TCOMMA TSTRUCTIDENT	{ printf("Structure intersection\n"); }
|  TMISDOPNOTSTR TSTRUCTIDENT TCOMMA TSTRUCTIDENT TCOMMA TSTRUCTIDENT		{ printf("Structure substraction\n"); }
;

str_compare_expr:
   TMISDOPGTSTR TSTRUCTIDENT TCOMMA TSTRUCTIDENT TCOMMA TIDENT			{ printf("Dissect structure by >\n"); }
|  TMISDOPLTSTR TSTRUCTIDENT TCOMMA TSTRUCTIDENT TCOMMA TIDENT			{ printf("Dissect structure by <\n"); }
|  TMISDOPLTESTR TSTRUCTIDENT TCOMMA TSTRUCTIDENT TCOMMA TIDENT			{ printf("Dissect structure by <=\n"); }
|  TMISDOPGTESTR TSTRUCTIDENT TCOMMA TSTRUCTIDENT TCOMMA TIDENT			{ printf("Dissect structure by >=\n"); }
;

str_transmission_expr:
   TMISDOPSENDTOSPU TIDENT	{ printf("Send identifier to SPU\n"); }
|  TMISDOPSENDTOCPU TIDENT	{ printf("Send identifier to CPU\n"); }
|  TMISDOPRECEIVEFROMSPU TIDENT	{ printf("Receive identifier from SPU\n"); }
|  TMISDOPRECEIVEFROMCPU TIDENT	{ printf("Receive identifier from CPU\n"); }
;

assign_stmt:
   TIDENT TASSIGN expr		{ data_type ident_type = getIdentType($1); buildAssignNode(ident_type); }
;

expr:
   TLP expr TRP			{ printf("Parenthesized expression\n"); }
|  expr TPLUS expr		{ printf("Sum\n"); }
|  expr TMINUS expr		{ printf("Substraction\n"); }
|  expr TMUL expr		{ printf("Multiplication\n"); }
|  expr TDIV expr		{ printf("Division\n"); }
|  expr TMOD expr		{ printf("Division (remaining num)\n"); }
|  expr TAND expr		{ printf("Logical AND\n"); }
|  expr TOR expr		{ printf("Logical OR\n"); }
|  TNOT expr			{ printf("Logical NOT\n"); }
|  TMISDOPSEARCHSTR TSTRUCTIDENT TCOMMA TIDENT			{ printf("Structure search\n"); }
|  TMISDOPSEARCHSMLSTR TSTRUCTIDENT TCOMMA TIDENT		{ printf("Structure search smaller than...\n"); }
|  TMISDOPSEARCHGRTSTR TSTRUCTIDENT TCOMMA TIDENT		{ printf("Structure search greater than...\n"); }
|  TMISDOPINSERTSTR TSTRUCTIDENT TCOMMA TIDENT TCOMMA TIDENT	{ printf("Insert into structure\n"); }
|  TMISDOPDELETEFROMSTR TSTRUCTIDENT TCOMMA TIDENT		{ printf("Delete from structure\n"); }
|  TMISDOPNEXTSTR TSTRUCTIDENT TCOMMA TIDENT			{ printf("Get the next element in structure\n"); }
|  TIDENT			{ printf("Identifier\n"); }
|  NUMLITERAL			{ printf("Number or literal\n"); }
;

if_stmt:
   TIF TLP bool_expr TRP TTHEN stmt %prec TNOELSE	{ printf("Pure if-statement\n"); }
|  TIF TLP bool_expr TRP TTHEN stmt TELSE stmt		{ printf("If-then-else statement\n"); }
;

bool_expr:
   expr log_op expr		{ printf("Boolean expression\n"); }
;

log_op:
   TLT				{ printf("Less than\n"); }
|  TGT				{ printf("Greater than\n"); }
|  TLTE				{ printf("Less than or equal to\n"); }
|  TGTE				{ printf("Greater than or equal to\n"); }
|  TEQ				{ printf("Equal\n"); }
;

loop_stmt:
   count_loop			{ printf("Count loop\n"); }
|  while_loop			{ printf("While loop\n"); }
;

count_loop:
   TFOR TLP assign_stmt TSEMI bool_expr TSEMI assign_stmt TSEMI TRP stmt	{ printf("For-loop with counter\n"); }
;

while_loop:
   TWHILE TLP bool_expr TRP TDO stmt		{ printf("While-do loop\n"); }
;

%%
